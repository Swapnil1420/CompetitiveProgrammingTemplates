<snippet>
	<content><![CDATA[
// LINES
/*
1. mi > mi+1, minimum.
2. mi > mi+1, maximum.
3. mi < mi+1, minimum.
4. mi < mi+1, maximum.
*/

struct line {
	ll m, c;
	line(ll a, ll b) {
		m = a, c = b;
	}
};

struct CHT {
	vector<line>v;
	int t, ptr;
	void init(int tp) {
		t = tp, ptr = 0, v.clear();
	}
	CHT(int tp) {
		t = tp, ptr = 0;
	}
	bool bad(line l1, line l2, line l3) {
		ll a = (ll)(l3.c - l1.c) * (l1.m - l2.m);
		ll b = (ll)(l2.c - l1.c) * (l1.m - l3.m);
		if (t == 1 or t == 4) return a <= b;
		return a >= b;
	}
	void add(line a) {
		v.pb(a);
		int sz = v.size();
		while (sz >= 3 && bad(v[sz - 3], v[sz - 2], v[sz - 1])) {
			v.erase(v.end() - 2), sz--;
		}
	}
	inline ll val(int ind, ll x) {
		return v[ind].m * x + v[ind].c;
	}
	ll query1(ll x) { //ternary search
		int l = 0, r = v.size() - 1;
		ll ans = 0;
		while (l <= r) {
			int mid1 = l + (r - l) / 3, mid2 = r - (r - l) / 3;
			if (t & 1) {
				if (val(mid1, x) <= val(mid2, x)) r = mid2 - 1, ans = val(mid1, x);
				else l = mid1 + 1, ans = val(mid2, x);
			}
			else {
				if (val(mid1, x) >= val(mid2, x)) r = mid2 - 1, ans = val(mid1, x);
				else l = mid1 + 1, ans = val(mid2, x);
			}
		}
		return ans;
	}
	ll query2(ll x) { //1,4 if xi<=xi+1; 2,3 if xi>=xi+1
		if (v.empty()) return 0;
		if (ptr >= v.size()) ptr = v.size() - 1;
		while (ptr < v.size() - 1) {
			if (t & 1) {
				if (val(ptr, x) > val(ptr + 1, x)) ptr++;
				else break;
			}
			else {
				if (val(ptr, x) < val(ptr + 1, x)) ptr++;
				else break;
			}
		}
		return val(ptr, x);
	}
};

// POINTS
struct Point {
    int x, y;
    bool operator < (Point P) const {
        if (x == P.x) return y < P.y;
        else return x < P.x;
    }
    bool operator == (Point P) const {
        return (x == P.x && y == P.y);
    }
};

bool cw(Point a, Point b, Point c) {
    return a.x * (c.y - b.y) + b.x * (a.y - c.y) + c.x * (b.y - a.y) > 0;
}
bool ccw(Point a, Point b, Point c) {
    return a.x * (c.y - b.y) + b.x * (a.y - c.y) + c.x * (b.y - a.y) < 0;
}
bool cll(Point a, Point b, Point c) {
    return a.x * (c.y - b.y) + b.x * (a.y - c.y) + c.x * (b.y - a.y) == 0;
}

vector<Point> convex_hull(vector<Point> points) {       // Not adding relaxed vertices
    if (points.size() <= 2) return points;
    sort(points.begin(), points.end());
    vector<Point> up, down;
    Point first = points[0], last = points.back();
    for (int i = 1; i < points.size(); i++) {
        if (i == 0 || i == points.size() - 1 || cw(first, points[i], last)) {
            while (up.size() >= 2 && !cw(up[up.size() - 2], up[up.size() - 1], points[i])) up.pop_back();
            up.push_back(points[i]);
        }
        if (i == 0 || i == points.size() - 1 || ccw(first, points[i], last)) {
            while (down.size() >= 2 && !ccw(down[down.size() - 2], down[down.size() - 1], points[i])) down.pop_back();
            down.push_back(points[i]);
        }
    }
    points.clear();
    for (int i = 0; i < up.size(); i++) points.push_back(up[i]);
    for (int i = 0; i < up.size(); i++) points.push_back(down[i]);
    uniq(points);
    return points;
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>convexHullTrick</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope>
</snippet>
